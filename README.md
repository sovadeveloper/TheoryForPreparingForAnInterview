# Теория для подготовки к собеседованию Java-разработчик (junior)

    Данный "справочник" не является авторским, а лишь собранная информация из открытого доступа в одном месте для удобства 

## Содержание

- [Java Core](#java-core)
  - [ООП. Наследование](#ооп-наследование)
  - [ООП. Инкапусляция](#ооп-инкапсуляция)
  - [ООП. Полиморфизм](#ооп-полиморфизм)
  - [ООП. Абстракция](#ооп-абстракция)
  - [Модификаторы доступа](#модификаторы-доступа)
  - [Конструктор](#конструктор)
  - [Связь любых классов с Object](#связь-любых-классов-с-object)
  - [Local Variable](#local-variable)
  - [Instance Variable](#instance-variable)
  - [Объект](#объект)
  - [Класс](#класс)
  - [Интерфейс](#интерфейс)
  - [Абстрактный класс](#абстрактный-класс)
  - [Абстрактный метод](#абстрактный-метод)
  - [Разница между интерфейсом и абстрактным классом](#разница-между-интерфейсом-и-абстрактным-классом)
  - [Типы данных](#типы-данных)
  - [Автоупаковка и автораспаковка](#автоупаковка-и-автораспаковка)
  - [Mutable и Immutable](#mutable-и-immutable)
  - [Final](#final)
  - [Static](#static)
  - [Сигнатура метода](#сигнатура-метода)
  - [Отношения между классами (объектами)](#отношения-между-классами-объектами)
  - [Ассоциация. Агрегация и композиция](#ассоциация-агрегация-и-композиция)
  - [Разница между == и equals()](#разница-между--и-equals)
  - [equals()](#equals)
  - [hashCode()](#hashcode)
  - [Контракт между equals() и hashCode()](#контракт-между-equals-и-hashcode)
  - [Правила переопределения equals()](#правила-переопределения-equals)
  - [Коллизия в hashCode](#коллизия-в-hashcode)
  - [Класс String](#класс-string)
  - [StringBuilder и StringBuffer](#stringbuilder-и-stringbuffer)
  - [String Pool (строковый пул)](#string-pool-строковый-пул)
  - [Память в Java](#память-в-java)
- [Java Collections](#java-collections)
  - [Иерархия коллекций](#иерархия-коллекций)
  - [ArrayList](#arraylist)
  - [LinkedList](#linkedlist)
  - [Сравнение ArrayList и LinkedList](#сравнение-arraylist-и-linkedlist)
  - [HashSet](#hashset)
  - [LinkedHashSet](#linkedhashset)
  - [TreeSet](#treeset)
  - [Map](#map)
  - [HashMap](#hashmap)
  - [HashTable](#hashtable)
  - [TreeMap](#treemap)
  - [Сравнение HashMap, HashTable и TreeMap](#сравнение-hashmap-hashtable-и-treemap)
  - [Вспомогательный класс Collections](#вспомогательный-класс-collections)
- [Java Exceptions](#java-exceptions)
  - [Что такое исключения в Java](#что-такое-исключения-в-java)
  - [Иерархия исключений](#иерархия-исключений)
  - [Checked и Unchecked исключения](#checked-и-unchecked-исключения)
  - [Обработка исключений. try и catch](#обработка-исключений-try-и-catch)
  - [Ключевые слова throw/throws](#ключевые-слова-throwthrows)
  - [Конструкция try-with-resources](#конструкция-try-with-resources)
  - [Создание своих исключений](#создание-своих-исключений)
  - [Разница между error и exception](#разница-между-error-и-exception)
- [Stream API](#stream-api)
  - [Введение в Stream API](#введение-в-stream-api)
  - [Создание потока данных](#создание-потока-данных)
  - [Фильтрация, перебор и отображение](#фильтрация-перебор-и-отображение)
  - [Сортировка](#сортировка)
  - [Получение подпотока и объединение потоков](#получение-подпотока-и-объединение-потоков)
  - [Методы skip и limit](#методы-skip-и-limit)
  - [Операции сведения](#операции-сведения)
  - [Метод reduce](#метод-reduce)
  - [Тип Optional](#тип-optional)
  - [Метод collect](#метод-collect)
  - [Группировка](#группировка)
  - [Параллельные потоки](#параллельные-потоки)
- [Spring Framework](#spring-framework)

# Java Core

____

## ООП. Наследование

С помощью наследования можно создавать дочерние классы ***(child)*** на основе родительских ***(parent)***, путем наследования свойств и поведения. В Java для наследования используется ключевое слово ***extends***

**Особенности наследования:**
-	Множественное наследование в Java отсутствует
-	Приватные поля и методы тоже наследуются, только к ним нет доступа у наследника (решение: геттеры и сеттеры)
-	final классы не наследуются
-	final методы не переопределяются
-	static методы и переменные не наследуются (так как привязаны к классам, а не объектам)
-	При наследовании от абстрактных классов, обязательна реализация их абстрактных методов, либо текущий класс тоже нужно объявить абстрактным
-	При наличии не дефолтных конструкторов в родителе, в классе потомке их необходимо переопределять
-	Переопределенным методам в наследнике можно расширять модификаторы доступа: private -> default -> protected -> public
-	Переопределенным методам можно сужать присваиваемые исключения: Exception -> IOException -> FileNotFoundException

[:top: Содержание](#содержание)

____

## ООП. Инкапсуляция

Сокрытие отдельных деталей внутреннего устройства классов от внешних по отношению к нему объектов или пользователей. За инкапсуляцию отвечают ***модификаторы доступа***

[:top: Содержание](#содержание)

____

## ООП. Полиморфизм

Возможность идентично использовать объекты с одинаковыми интерфейсами без информации о конкретном типе этого объекта. Один интерфейс – множество реализаций. В Java за полиморфизм отвечают ключевые слова ***extends*** и ***implements***
Существует два вида полиморфизма – раннее и позднее связывание

**Статический полиморфизм (раннее связывание):**
- Происходит во время компиляции
- Решает, какой метод выполнять во время компиляции
- Перегрузка методов – пример статического полиморфизма
- К нему относятся приватные, статические и терминальные методы
- Наследование не участвует в раннем связывании
- В статическом полиморфизме участвуют не конкретные объекты, а информация о классе, тип которого представлен 

**Динамический полиморфизм (позднее связывание):**
- Происходит во время выполнения
- Решает, какая конкретно реализация будет у метода во время выполнения 
- Переопределение метода – пример динамического полиморфизма
- Позднее связывание – это назначение конкретного объекта, ссылки его типа или его суперкласса
- Наследование связано с динамическим полиморфизмом

[:top: Содержание](#содержание)

____

## ООП. Абстракция

Придание объекту характеристик, которые отличают его от всех других объектов, четко определяя его концептуальные границы.  В Java за абстракцию отвечают ***интерфейсы***

[:top: Содержание](#содержание)

____

## Модификаторы доступа

Инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.
- private – только класс, внутри которого он объявлен
- default (не указан) – доступ только в конкретном пакете, в котором объявлен класс, метод, переменная
- protected – такой же доступ как в default, но еще и для тех классов, которые наследуются от класса с модификатором protected
- public – полный доступ во всем приложении

[:top: Содержание](#содержание)

____

## Конструктор

- Когда новый объект создается, программа использует для этого соответствующий конструктор
- Конструктор похож на метод. Его особенность заключается в том, что нет возвращаемого элемента, а его имя совпадает с именем класса
- Если не создается явно ни одного конструктора, то пустой конструктор будет создан автоматически
- Конструктор может быть переопределен
- Если был создан конструктор с параметрами, а нужен еще и пустой, то его нужно писать отдельно, так как он не создается автоматически при уже существующем с параметрами

[:top: Содержание](#содержание)

____

## Связь любых классов с Object

Все классы прямо или через предков наследуются от класса Object

[:top: Содержание](#содержание)

____

## Local variable

Переменная, которая определена внутри метода и существует до тех пор, пока выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать

[:top: Содержание](#содержание)

____

## Instance Variable

Переменная, которая определена внутри класса, и она существует до того момента, пока существует объект

[:top: Содержание](#содержание)

## Объект

Объекты – некоторые сгруппированные, в которых содержатся различные методы, для работы с этими данными

[:top: Содержание](#содержание)

____

## Класс

Класс – шаблон для создания объектов. Может быть множество объектов одного класса

[:top: Содержание](#содержание)

____

## Интерфейс

Совокупность методов и правил взаимодействия элементов системы. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой
- Все методы в интерфейсы публичные и абстрактные 
- Все переменные public static final
- Бесконечное кол-во имплементаций
- Классы, которые реализуют интерфейс должны предоставить реализацию всех методов, которые есть в интерфейсе

[:top: Содержание](#содержание)

____

## Абстрактный класс

Класс, который не может иметь экземпляров. Так же он может содержать абстрактные методы

[:top: Содержание](#содержание)

____

## Абстрактный метод

Метод, который создан без реализации с ключевым словом abstract в абстрактном классе

[:top: Содержание](#содержание)

____

## Разница между интерфейсом и абстрактным классом

**Абстрактный класс:**
- Имеет дефолтный конструктор; вызывается при создании потомка
- Содержит как абстрактные методы, так и не абстрактные
- Класс, который наследуется от абстрактного, должен реализовывать только абстрактные методы
- Абстрактный класс может содержать Instance Variable

**Интерфейс:**
- Не имеет никакого конструктора и не может быть инициализирован
- Содержит только абстрактные методы
- Класс, реализующий интерфейс, должен реализовать все методы
- Интерфейсы могут содержать только константы

[:top: Содержание](#содержание)

____

## Типы данных 

В Java типы данных бывают двух видов: примитивные и ссылочные

**Примитивные:**
1)	Целые числа (byte, short, int, long)
2)	Числа с плавающей точкой (float, double)
3)	Логический (Boolean)
4)	Символьный (char)

**Ссылочные:**
1)	Классы
2)	Интерфейсы
3)	Массивы
4)	String

| Примитивные | Ссылочные |
| ----------- | --------- |
| Хранят значение | Хранят ссылку объекта в памяти, на который ссылаются |
| Создаются присваиванием значения | Создаются через конструктор класса (присваивание только создает вторую ссылку) |
| Имеют строго заданный диапазон допустимых значений | По умолчанию – null |
| В аргументы методов попадают копии значения переменной |В методы передается значение ссылки – операция выполняется над оригинальным объектом, на который ссылается переменная|
|  | Могут использоваться для ссылки на любой объект объявленного или совместимого типа |

[:top: Содержание](#содержание)

____

## Автоупаковка и автораспаковка

***Автоупаковка*** – процесс автоматического преобразования из примитивного типа в соответствующий класс обертку

***Автораспаковка*** – преобразование класса обертки в примитив. При null -> исключение NPE (NullPointerException)

[:top: Содержание](#содержание)

____

## Mutable и Immutable

***Mutable*** – объекты, состояние и переменные которых можно изменить после создания

***Immutable*** – объекты, состояние которых нельзя изменить после создания

[:top: Содержание](#содержание)

____

## Final

***final*** можно использовать для переменных, методов и классов
- final переменную нельзя переназначить на другой объект
- final метод не может быть переопределен
- final класс не может иметь наследников

[:top: Содержание](#содержание)

____

## Static

***static*** – модификатор, применяемый к полю, блоку, методу или внутреннему классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу

- НЕЛЬЗЯ получить доступ к НЕ статическим членам класса, внутри статического контекста (метода/блока/…)
- В отличии от локальных переменных, статические поля и методы НЕ потокобезопасны. Учитывая, что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите. При использовании статических переменных они должны бить синхронизированы (synchronized) 
- Применяя статические методы, отсутствует необходимость каждый раз создавать новый объект. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны
- Нельзя переопределить статические методы. При попытке переопределения лишь спрячем метод суперкласса, такое явление называется сокрытием
- Объявить статическим можно и класс, за исключением класса верхнего уровня. Такие классы известны как “вложенные статические классы” (nested static class). Они бывают полезными для представления улучшенных связей
- Модификатор static так же можно объявить в статическом блоке инициализации, который будет выполнен во время загрузки класса
- Статические методы связываются во время компиляции, в отличии от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно статические методы не могут быть переопределены, так как полиморфизм во время выполнения не распространяется на них
- Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса
- Во время сериализации статические поля, переменные не сериализуются
- static import. Данный модификатор имеет много общего со стандартным import, но в отличии от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, можно получить доступ без указания имени класса

[:top: Содержание](#содержание)

____

## Сигнатура метода

Сигнатура метода – это имя метода плюс его аргументы (причем порядок аргументов имеет значение). В сигнатуру метода не входит возвращаемое значение, а также бросаемы исключения.

Пример правильной сигнатуры:

```java
  doSomething(int a, double b, double c)
```

Пример неправильной сигнатуры: 

```java
  int doSomething(int firstArg, int secondArg) throws Exception
```

Сигнатура метода в сочетании с возвращаемым типом и бросаемыми исключениями называется **контрактом метода**

[:top: Содержание](#содержание)

____

## Отношения между классами (объектами) 

В Java есть два вида отношений

***IS-A:***

Принцип IS-A в ООП основан на наследовании классов или реализации интерфейсов. К примеру, если класс **Lion** наследует класс **Cat**, мы говорим, что **Lion** является **Cat**

    Lion IS-A Cat
    
(но не всякий **Cat** является **Lion**)

***HAS-A:***

***Ассоциация*** – это один класс ссылается на другой (или на друг друга)

Например, класс **Car** может ссылаться на класс **Passenger**:

    Car HAS-A Passenger
    
И наоборот: если **Passenger** имеет ссылку на **Car**:

    Passenger HAS-A Car

[:top: Содержание](#содержание)

____

## Ассоциация. Агрегация и композиция

Агрегация и композиция – частные случаи ассоциации

***Агрегация*** – отношение, когда один объект является частью другого (но не обязательно это связь должна быть). Например: пассажир может находиться в машине, так же их может быть несколько или не быть совсем. Один пассажир, несколько или ни одного – от этого не зависит работоспособность второго в агрегации класса. Агрегация более свободные ассоциативные отношения классов.

***Композиция*** – более жесткое отношение, когда объект является не просто частью другого, но и работа второго зависит от первого. Например, двигатель может быть без машины, но вне машины он бесполезен, так же и машина не может работать без двигателя.

[:top: Содержание](#содержание)

____

## Разница между == и equals()

При сравнении примитивных типов используется ==, так как переменные содержат конкретные значения и есть возможность их сравнить. Так же примитивные переменные не являются объектами – они не наследуются от класса Object и не имеют метода equals().
Когда сравниваем ссылочные переменные, то == будет сравнивать лишь значение ссылок, на тот же объект ведет ссылка или нет. И даже при условии, что объекты идентичны, то результат такого сравнения будет **false**, так как это другой объект.
Для сравнения ссылочных переменных надо использовать метод equals().
Важно заметить, что для корректной работы метода equals() его необходимо переопределить, в противном случае он будет работать так же, как и ==

[:top: Содержание](#содержание)

____

## equals()

***equals()*** – метод класса Object, задача которого сравнивать объекты и определять равны они или нет

[:top: Содержание](#содержание)

____

## hashCode()

***hashCode()*** – метод класса Object, который генерирует некоторое число на основе предоставленного объекта

[:top: Содержание](#содержание)

____

## Контракт между equals() и hashCode()

Для корректной работы методов equals() и hashCode() в первую очередь их нужно переопределить.
После чего они должны соблюдать правила:
- Одинаковые объекты, для которых сравнение через equals() возвращает **true**, обязательно имеют одинаковые хэш-коды
- Объекты с одинаковыми хэш-кодами не всегда могут быть равны

[:top: Содержание](#содержание)

____

## Правила переопределения equals()

***Рефлексивность*** – для любого значения **x** выражение вида ```x.equals(x)``` всегда должно возвращать **true** (если ```x != null```)

***Симметричность*** – для любых значений **x** и **y** выражение вида ```x.equals(y)``` должно возвращать **true** только в том случае, если ```y.equals(x)``` тоже возвращает **true**

***Транзитивность*** – для любых значений **x**, **y** и **z**, если выражение ```x.equals(y)``` возвращает **true**, при этом ```y.equals(z)``` тоже возвращает **true**, тогда и ```x.equals(z)``` должно возвращать **true**

***Согласованность*** – для любых значение **x** и **y** повторный вызов ```x.equals(y)``` будет всегда возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения двух объектов, не были изменены между вызовами

***Сравнение null*** – для любого значения **x** вызов ```x.equals(null)``` всегда будет возвращать **false**

[:top: Содержание](#содержание)

____

## Коллизия в hashCode

***Коллизия*** – это ситуация, когда два разных объекта имеют одинаковые хэш-коды
Для борьбы с коллизией нужно иметь хорошую имплементацию метода hashCode, чтобы разброс значений был максимальным и шанс повторения значений был минимальным

[:top: Содержание](#содержание)

____

## Класс String

***String*** – стандартный класс в Java, отвечающий за хранение и манипуляции со строковыми значениями, является immutable классом. Так же String является final. 
Особенности:
- Благодаря неизменности, хэш-код экземпляра класса кэшируется. Его не нужно вычислять каждый раз
- Класс String можно использовать в многопоточной среде без дополнительной синхронизации
- Для него перегружен оператор ```+``` для конкатенации строк, поэтому она выполняется быстро. Под капотом конкатенация строк выполняется StringBuilder’ом или StringBuffer’ом (на усмотрение компилятора) и методом append

[:top: Содержание](#содержание)

____

## StringBuilder и StringBuffer

Это два фактически одинаковых класса с той лишь разницей, что один из них используется в многопоточной среде (StringBuffer)

[:top: Содержание](#содержание)

____

## String Pool (строковый пул)

В памяти Java (Heap) есть область - строковый пул, которая предназначена для хранения строковых значений. 
Например, при создании строки:

```java
  String str = “Hello, World!”;
```

Происходит проверка, имеется ли такое значение в строковом пуле, если нет, то создается новое значение, если имеется, то присваивается ссылка на существующее.
При необходимости можно создать новое значение в пуле даже если такое уже существует, через оператор ```new```

[:top: Содержание](#содержание)

____

## Память в Java

Для оптимальной работы приложения JVM делит память на две области: ***стек (stack)*** и ***куча (heap)***. Каждый раз при создании переменной, обновления переменной, создании метода JVM выделяет область памяти под это в стеке или куче.

***Стек:***

Стек работает по схеме LIFO - last in first out (последний вошел, первый вышел)
При каждом вызове метода, который содержит примитивные значения или ссылки на объекты в куче, то на вершине стека выделяется блок памяти под них
Стек хранит примитивные значения, создаваемых в методах, а также ссылки на объекты в куче, на которые ссылается метод

![стек](https://static.tildacdn.com/tild3461-6261-4863-a635-653039613337/PROgrammer-Stack_1.gif)

Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится свободным для следующего метода.
Особенности стека:
- Стек заполняется и очищается по мере вызова и завершения методов
- Переменные в стеке существуют до тех пор, пока выполняется метод, в котором они были созданы
- Если память стека будет заполнена, то выбросится исключение StackOverFlowError
- Доступ к стеку осуществляется быстрее, чем к куче
- Является потокобезопасным, так как для каждого потока создается свой стек

***Куча:***

Эта область памяти используется для динамического выделения памяти для объектов и классов JRE во время выполнения. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.
Эта область памяти разбита на несколько частей, которые называются поколения:
1) ***Young Generation*** – область, где размещаются новые созданные объекты. Когда она заполняется происходит сборка мусора.
2) ***Old (Tenured) Generation*** – здесь хранятся долгоживущие объекты. Когда объекты из ***Young Generation*** достигают определенного “возраста”, они перемещаются в ***Old Generation***.
3) ***Permanent Generation*** – эта область содержит метаинформацию о классах и методах приложения, но начиная с java 8 данная область памяти была упразднена. 

![куча](https://thumb.tildacdn.com/tild6565-3134-4634-b335-353038373763/-/format/webp/image.png)

Особенности кучи:
- Когда эта область памяти заполняется, то выбрасывается исключение OutOfMemoryError
- Доступ к ней медленнее, чем к стеку
- Эта памяти, в отличии от стека автоматически не освобождается. Для сбора неиспользуемых объектов здесь используется сборщик мусора
- В отличии от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код

[:top: Содержание](#содержание)

____

# Java Collections

____


## Иерархия коллекций

Существует две иерархии коллекций в Java

**Первая** – непосредственно ***Collection***:

![collection](https://cdn.javarush.ru/images/article/8cc198bf-1349-45d3-9475-c19ca5d6a622/800.webp)

- Set – интерфейс, описывающий такую структуру данных, как множество, содержащее неупорядоченные уникальные элементы. У интерфейса есть стандартные реализации – HashSet, TreeSet, LinkedHashSet
- List – интерфейс, описывающий структуру данных, которая хранит упорядоченную последовательность объектов. Стандартные реализации – ArrayList, LinkedList
- Queue – интерфейс, описывающий структуру данных, хранящую элементы в виде очереди, которая следует правилу FIFO – first in first out (первый ушел, первый пришел). Стандартные реализации – LinkedList, PriorityQueue

**Вторая** - ***Map***:

![Map](https://cdn.javarush.ru/images/article/7a7daedd-9e51-48ba-8b52-5cc9bb393037/800.webp)

Тут подразделений как таковых нет, так как эта коллекция является в своем роде подколлекцией, которая лежит отдельно. Стркутура данных ***Map*** подразумевает, что в ней хранятся даные в виде пар ключ-значение

![key-value](https://cdn.javarush.ru/images/article/6db9cc95-cc5a-4718-83ee-faa18408208a/800.webp)

[:top: Содержание](#содержание)

____

## ArrayList

***ArrayList*** – реализация изменяемого массива интерфейса ***List***, который отвечает за список (динамический массив). Этот класс реализует все необязательные операции со списком и предоставляет методы управления размером массива, который используется для хранения списка. 
В основе лежит идея динамического массива. А именно, возможность добавлять и удалять элементы, при этом будет увеличиваться или уменьшаться по необходимости.
В ArrayList можно хранить только ссылочные типы, для хранения примитивов необходимо использовать классы-обертки.

У ArrayList есть 3 конструктора:
1) Пустой конструктор с начальной емкостью массива = 10
2) Конструктор, который ждет на входе другую коллекцию, на основе которой создаст список
3) С параметром int, который выступает в роли начальной емкости списка

При заполнении списка он автоматически расширяется путем создания нового массива и переносом элементов по формуле: ``` размер старого массива * 1.5 + 1 ```

Особенности ArrayList:
- Вставка в конец и доступ по индексу очень быстрые O(1)
- Что бы вставить элемент в начало или середину, понадобиться скопировать все элементы на одну ячейку вправо, а затем вставить новый элемент в нужную позицию
- Доступ по значению зависит от количества элементов O(n)
- В отличии от классического массива может хранить null

[:top: Содержание](#содержание)

____

## LinkedList

***LinkedList*** – двусвязный список. Все элементы по сути являются одной цепью. У каждого элемента помимо тех данных, которые он хранит имеется ссылка на следующий и предыдущий элементы. По этим ссылкам можно переходить от одного элемента к другому.

![linkedlist](https://cdn.javarush.ru/images/article/26df2269-a6af-427b-89df-3cc66a5b2ab0/800.webp)

Внутри ***LinkedList*** есть главный объект – ***head***, который хранит информацию о количестве элементов, а также ссылку на первый и последний элементы.

![headlinkedlist](https://cdn.javarush.ru/images/article/aacc5b05-f7b5-4555-9787-766670051764/800.webp)

На данном этапе поле **size** = 0, а ссылки **first** и **last** = null. После добавления элемента список будет выглядеть следующим образом:

![firstelemlinkedlist](https://cdn.javarush.ru/images/article/94380a69-0fc5-491a-bf7e-3bc94b56d9e5/800.webp)

Теперь **size** = 1, а **first** и **last** указывают на “ноду” - “Johnny”.

Добавим еще один элемент в список:

![secondelemlinkedlist](https://cdn.javarush.ru/images/article/6bc56b53-34aa-431a-87ff-a87bed0a0730/800.webp)

Теперь в **head** **size** = 2, **first** указывает на “Johnny’, **last** указывает на “Watson”. 

Нода “Johnny”: **previous** = null (так как это первая нода), **next** = “Watson”

Нода “Watson”: **previous** = “Johnny”, **next** = null (так как это последняя нода)

Вот по какому принципу добавляются элементы в середину списка:

![nextelemslinkedlist](https://cdn.javarush.ru/images/article/90bc2953-931f-4e8f-ba82-93076b0444b5/800.webp)

Добавлен новый элемент “Hamish”, для этого было нужно просто переприсвоить ссылки на элементы.

Особенности LinkedList:
- Так же, как и массив, индексируется с 0
- Доступ к первому и последнему элементу не зависят от количества элементов – O(1)
- Получение элемента по индексу, вставка или удаление из середины списка зависят от количества элементов – O(n)
- Можно использовать механизм итератора: тогда вставка и удаление будут происходить за константное время
- В отличии от классического массива, может хранить null

[:top: Содержание](#содержание)

____

## Сравнение ArrayList и LinkedList

***ArrayList*** следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время. Минусы в скорости вставки/удаления из середины списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.

***LinkedList*** удобен когда важнее быстродействие операций удаления/вставки, так как выполняются за константное время. Операции доступа по индексу производятся путем перебора с начала или конца.

Если необходимо часто вставлять/удалять из середины списка – лучше использовать ***LinkedList***, во всех остальных случаях ***ArrayList***

| Операция | ArrayList | LinkedList |
| -------- | --------- | ---------- |
| get | O(1) | O(n) |
| add | O(1)* | O(1) |
| add(index, value) | O(n) | O(n-index) |
| remove | O(n) | O(n-index) |

[:top: Содержание](#содержание)

____

## HashSet

Класс ***HashSet*** реализует интерфейс ***Set***, основан на хэш-таблице, а также поддерживается с помощью экземпляра ***HashMap***. В ***HashSet*** элементы не упорядочены, нет никаких гарантий, что элементы будут в том же порядке спустя какое-то время. Операции добавления, удаления и поиска будут выполняться за константное время при условии, что хэш-функция правильно распределяет элементы по «корзинам».

Особенности: 
- Т.к. класс реализует интерфейс Set, он может хранить только уникальные значения
- Может хранить NULL – значения
- Порядок добавления элементов вычисляется с помощью хэш-кода

Для поддержания постоянного времени выполнения операций время, затрачиваемое на действия с ***HashSet***, должно быть прямо пропорционально количеству элементов в HashSet + «емкость» встроенного экземпляра ***HashMap*** (количество «корзин»). Поэтому для поддержания производительности очень важно не устанавливать слишком высокую начальную ёмкость (или слишком низкий коэффициент загрузки).

***Начальная емкость*** – изначальное количество ячеек («корзин») в хэш-таблице. Если все ячейки будут заполнены, их количество увеличится автоматически.

***Коэффициент загрузки*** – показатель того, насколько заполненным может быть ***HashSet*** до того момента, когда его емкость автоматически увеличится. Когда количество элементов в ***HashSet*** становится больше, чем произведение начальной емкости и коэффициента загрузки, хэш-таблица ре-хэшируется (заново вычисляются хэшкоды элементов, и таблица перестраивается согласно полученным значениям) и количество ячеек в ней увеличивается в 2 раза.

```
  Коэффициент загрузки = Количество хранимых элементов в таблице / размер хэш-таблицы
```

Коэффициент загрузки и начальная емкость – два главных фактора, от которых зависит производительность операций с ***HashSet***. Коэффициент загрузки, равный ```0,75```, в среднем обеспечивает хорошую производительность. Если этот параметр увеличить, тогда уменьшится нагрузка на память (так как это уменьшит количество операций ре-хэширования и перестраивания), но это повлияет на операции добавления и поиска. Чтобы минимизировать время, затрачиваемое на ре-хэширование, нужно правильно подобрать параметр начальной емкости. Если начальная емкость больше, чем максимальное количество элементов, поделенное на коэффициент загрузки, то никакой операции ре-хэширования не произойдет в принципе.

***HashSet*** не является структурой данных с встроенной синхронизацией, поэтому если с ним работают одновременно несколько потоков, и как минимум один из них пытается внести изменения, необходимо обеспечить синхронизированный доступ извне. Часто это делается за счет другого синхронизируемого объекта, инкапсулирующего ***HashSet***. Если такого объекта нет, то лучше всего подойдет метод ```Collections.synchronizedSet()```. На данный момент это лучшее средство для предотвращения несинхронизированных операций с ***HashSet***.

Конструкторы HashSet:
1) ``` HashSet h = new HashSet(); ``` — конструктор по умолчанию. Начальная емкость по умолчанию – ```16```, коэффициент загрузки – ```0,75```.
2) ``` HashSet h = new HashSet(int initialCapacity); ``` – конструктор с заданной начальной емкостью. Коэффициент загрузки – ```0,75```.
3) ``` HashSet h = new HashSet(int initialCapacity, float loadFactor); ``` — конструктор с заданными начальной емкостью и коэффициентом загрузки.
4) ``` HashSet h = new HashSet(Collection C); ``` – конструктор, добавляющий элементы из другой коллекции.

Все классы, реализующие интерфейс ***Set***, внутренне поддерживаются реализациями ***Map***. ***HashSet*** хранит элементы с помощью ***HashMap***. Хоть и для добавления элемента в ***HashMap*** он должен быть представлен в виде пары «ключ-значение», в  ***HashSet*** добавляется только значение.

На самом деле значение, которые мы передаем в ***HashSet***, является ключом к объекту ***HashMap***, а в качестве значения в ***HashMap*** используется константа. Таким образом, в каждой паре «ключ-значение» все ключи будут иметь одинаковые значения.

***HashSet*** основан на хэш-таблице, и операции добавления, удаления или поиска в среднем будут выполняться за константное ```О(1)``` время.

[:top: Содержание](#содержание)

____

## LinkedHashSet

Класс ***LinkedHashSet*** расширяет класс ***HashSet***, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

[:top: Содержание](#содержание)

____

## TreeSet 

Класс ***TreeSet*** в Java обеспечивает реализацию интерфейса ***Set***, который использует древо для хранения. Объекты хранятся в отсортированном и возрастающем порядке.

Время доступа и поиска довольно быстрое, что делает ***TreeSet*** отличным выбором при хранении большого количества отсортированной информации, которая должна быть найдена быстро.

Конструкторы:
1) ``` TreeSet(); ``` - Этот конструктор создает пустое дерево, которое будет сортироваться в порядке возрастания в соответствии с естественным порядком его элементов.
2) ```TreeSet(Collection c); ``` - Этот конструктор создает набор деревьев, содержащий элементы коллекции c.
3) ``` TreeSet(Comparator comp); ``` - Этот конструктор создает пустой набор деревьев, который будет сортироваться в соответствии с данным компаратором.
4) ``` TreeSet(SortedSet ss) ``` - Этот конструктор создает TreeSet, который содержит элементы данного SortedSet.

[:top: Содержание](#содержание)

____

## Map

***Map*** — это структура данных, которая содержит набор пар “ключ-значение”. По своей структуре данных напоминает словарь, поэтому ее часто так и называют. В то же время, ***Map*** является интерфейсом, и в стандартном jdk содержит основные реализации: ***Hashmap, LinkedHashMap, Hashtable, TreeMap***. Самая используемая реализация — ***Hashmap***.

[:top: Содержание](#содержание)

____

## HashMap

***HashMap*** работает с парами ключ – значение. 

Внутри HashMap есть массив нод:

``` Node<K,V>[] table ```

По умолчанию размер массива — ```16```, и он увеличивается каждый раз в два раза по мере заполнения элементами (при достижении ```LOAD_FACTOR``` — определенного процента заполненности, по умолчанию он — ```0.75```).

Каждая из нод хранит в себе хеш ключа, ключ, значение, ссылку на следующий элемент:

![nodehashmap](https://cdn.javarush.ru/images/article/9932ab13-5613-41f8-8bc4-e018a9b980f3/512.webp)

Собственно, “ссылка на следующий элемент” означает, что мы имеем дело с односвязным списком, где каждый элемент содержит ссылку на следующий.

То есть ***HashMap*** хранит данные в массиве односвязных списков.
 
Когда одна ячейка массива ```table``` имеет ссылку на подобный односвязный список, состоящий из более чем одного элемента, это не есть хорошо. Такое явление называется ***коллизия***.

Сперва берется ```hachCode()``` ключа. Поэтому для корректной работы ***HashMap*** в качестве ключей нужно брать классы, в которых данный метод переопределен.

Далее этот хеш код используется во внутреннем методе — ```hash()``` — для определения числа в пределах размера массива ```table```.

Далее по полученному числу, идёт обращение к конкретной ячейке массива ```table```.

Далее два варианта:
1) Ячейка пустая — в нее сохраняется новое значение ```Node```.
2) Ячейка не пустая — сравнивается значение ключей. Если они равны, новое значение ```Node``` перезаписывает старое, если не равны — идёт обращение к элементу ***next*** (следующему), идёт сравнение уже с его ключом… И так до тех пор, пока новое значение не перезапишет некоторое старое или не достигнет конца односвязного списка и сохранится там последним элементом.

При поиске элемента по ключу (метод ```get(<key>)```), вычисляется ***hashCode*** ключа, потом его значение в пределах массива с помощью ```hash()```, и по полученному числу находится ячейка массива ```table```, в которой уже ведется поиск путем перебора нод и сравнения ключа искомой ноды с ключом текущей.

Операции в ***Map*** при идеальном раскладе имеют алгоритмическую сложность ```O(1)```, ведь идёт обращение к массиву; независимо от количества элементов операции у массива имеют сложность ```O(1)```.

Когда используемая ячейка массива не пустая и там уже есть некоторые ноды, алгоритмическая сложность превращается в линейную ```O(N)```, ведь теперь необходимо перебрать элементы, прежде чем найдется нужное место.

Начиная с Java 8, если у односвязного списка ```node``` больше 8 элементов (коллизии), он превращается в двоичное дерево. В таком случае алгоритмическая сложность будет уже не ```O(N)```, а ```O(log(N))```

[:top: Содержание](#содержание)

____

## HashTable

Как и ***HashMap***, в Java ***Hashtable*** хранит пары ключей/значений в хэш-таблице. Используя ***Hashtable***, вы указываете объект, который используется как ключ, и значение, которое вы ходите связать с этим ключом. Этот ключ затем хэшируется, а полученный хэш-код используется как индекс, в котором значение хранится в таблице.

HashTable - синхронизирован

Констркуторы: 
1) ```Hashtable();``` - Этот стандартный конструктор хэщ-таблицы, который создаёт экземпляр класса Hashtable.
2) ```Hashtable(int size);``` - Этот конструктор принимает целочисленный параметр и создаёт хэш-таблицу, имеющая начальный размер, заданный размером целочисленного значения.
3) ```Hashtable(int size, float fillRatio);``` - Это создаёт хэш-таблицу, в которой есть начальный размер, указанный в ```size```, и коэффициент заполнения, заданный ```fillRatio```. Этот коэффициент должен принимать значение между ```0.0``` и ```1.0```, и он определяет, насколько полной может быть хэш-таблица прежде чем она будет изменена в размерах.
4) ```Hashtable(Map < ? extends K, ? extends V > t);``` - Это построит Hashtable с указанными отображениями.

[:top: Содержание](#содержание)

____

## TreeMap

Класс ***TreeMap*** в Java реализует интерфейс ***Map***, используя дерево. ***TreeMap*** обеспечивает эффективное средство хранения пар ключ/значение в отсортированном порядке и позволяет быстро извлекать данные.

Следует отметить, что, в отличие от хэш-карты, карта деревьев гарантирует, что ее элементы будут отсортированы в порядке возрастания ключа.

Конструкторы:
1) ```TreeMap();``` - Этот конструктор создает пустое дерево, которое будет сортироваться по естественному порядку его ключей.
2) ```TreeMap(Comparator comp);``` - Этот конструктор создает пустую древовидную карту, которая будет сортироваться с использованием компаратора comp.
3) ```TreeMap(Map m);``` - Этот конструктор инициализирует древовидную карту с элементами из ***m***, которые будут отсортированы с использованием естественного порядка ключей.
4) ```TreeMap(SortedMap sm);``` - Этот конструктор инициализирует карту дерева с записями из ***SortedMap sm***, которые будут отсортированы в том же порядке, что и ***sm***.

***TreeMap*** имплементирует интерфейс ***NavigableMap***, который наследуется от ***SortedMap***. Имплементируя интерфейсы ***NavigableMap*** и ***SortedMap***, ***TreeMap*** получает дополнительный функционал, которого нет в ***HashMap***, но плата за это — производительность. 

Под капотом ***TreeMap*** использует структуру данных, которая называется ***красно-чёрное дерево***. 

[:top: Содержание](#содержание)

____

## Сравнение HashMap, HashTable и TreeMap

1) ***Порядок элементов***. `HashMap` и `Hashtable` не гарантируют, что элементы будут храниться в порядке добавления. Кроме того, они не гарантируют, что порядок элементов не будет меняться со временем. В свою очередь, `TreeMap` гарантирует хранение элементов в порядке добавления или же в соответствии с заданным компаратором.
2) ***Допустимые значения***. `HashMap` позволяет иметь ключ и значение null, `HashTable` — нет. `TreeMap` может использовать значения null только если это позволяет компаратор. Без использования компаратора (при хранении пар в порядке добавления) значение null не допускается.
3) ***Синхронизация***. Только `HashTable` синхронизирована, остальные — нет. Если к мапе не будут обращаться разные потоки, рекомендуется использовать `HashMap` вместо `HashTable`.

| Сравнение | HashMap | HashTable | TreeMap |
| --------- | ------- | --------- | ------- |
| Упорядоченность элементов | Нет | Нет | Да | 
| null в качестве значения | Да | Нет | Да/Нет |
| Потокобезопасность | Нет | Да | Нет |
| Алгоритмическая сложность поиска элементов | O(1) | O(1) | 	O(log n) |
| Структура данных под капотом | Хэш-таблица | Хэш-таблица | 	Красно-чёрное дерево |

[:top: Содержание](#содержание)

____

## Вспомогательный класс Collections

| Методы | Описание |
| ------ | -------- |
| `addAll(colls, e1, e2, e3, ..)` | 	Добавляет в коллекцию `colls` элементы `e1`, `e2`, `e3`,... |
| `fill(list, obj)` | Заменяет в переданном списке все элементы на `obj` | 
| `nCopies(n, obj)` | Возвращает список, состоящий из `n` копий объекта `obj` |
| `replaceAll(list, oldVal, newVal)` | Заменяет в списке `list` все значения `oldVal` на `newVal` | 
| `copy(dest, src)` | Копирует все элементы из списка `src` в список `dest` |
| `reverse(list)` | Разворачивает список задом наперед | 
| `sort(list)` | Сортирует список в порядке возрастания |
| `rotate(list, n)` | Циклично сдвигает элементы списка `list` на `n` элементов |
| `shuffle(list)` | Случайно перемешивает элементы списка |
| `min(colls)` | Находит минимальный элемент коллекции `colls` |
| `max(colls)` | Находит максимальный элемент коллекции `colls` |
| `frequency(colls, obj)` | Определяет, сколько раз элемент `obj` встречается в коллекции `colls` |
| `binarySearch(list, key)` | Ищет элемент `key` в отсортированном списке, возвращает индекс. |
| `disjoint(colls1, colls2)` | Возвращает `true`, если у коллекций нет общих элементов |

[:top: Содержание](#содержание)

____

# Java Exceptions

____

## Что такое исключения в Java

***Исключение в Java*** — представляет проблему, которая возникает в ходе выполнения программы. В случае возникновения в Java исключения (exception), или исключительного события, имеет место прекращение нормального течения программы, и программа/приложение завершаются в аварийном режиме, что не является рекомендованным, и, как следствие, подобные случаи требуют в Java обработку исключений.

[:top: Содержание](#содержание)

____

## Иерархия исключений 

Все классы исключений в Java представляют подтипы класса `java.lang.Exception`. Класс исключений является подклассом класса `Throwable`. Помимо класса исключений существует также подкласс ошибок, образовавшихся из класса `Throwable`.

Ошибки представляют аварийное состояние вследствие значительных сбоев, которые не обрабатываются программами Java. Генерирование ошибок предназначено для отображения ошибок, выявленных средой выполнения. Примеры: JVM исчерпал имеющийся объем памяти. Обычно, программы не могут восстановить неполадки, вызванные ошибками.

Класс исключений делится на два основных подкласса: класс IOException и класс RuntimeException.

![hierarchyexceptions](https://www.pvsm.ru/images/2020/01/05/Java-svertyvanie-mnogostrochnyh-logov-v-odnostrochnyi-log-s-pomoshyu-Spirng-i-loggera-Logback-ili-Log4j2-3.jpeg)

[:top: Содержание](#содержание)

____

## Checked и Unchecked исключения

***Checked*** - исключения, которые проверяются во время компиляции. Ксли какой-то код в методе во время исполнения выбьет checked исключение, метод обязан либо обработать его при помощи try-catch, либо пробросить его дальше.

***Unchecked*** - исключения, которые на этапе компиляции не проверяются. То есть метод может генерировать `RuntimeException`, а компилятор не напомнит каким-то образом это обработать.

***Примеры checked исключений:*** `Throwable`, `Exception`, `IOException`, `FileNotFoundException`, `SocketException`

***Примеры unchecked исключений:*** `Error`, `OutOfMemoryError`, `StackOverFlowError`, `RuntimeException`, `IllegalArgumentException`

[:top: Содержание](#содержание)

____

## Обработка исключений. try и catch

Блок try/catch размещается в начале и конце кода, который может сгенерировать исключение. Код в составе блока try/catch является защищенным кодом, синтаксис использования try/catch выглядит следующим образом:

```java
  try {
   // Защищенный код
  }catch(НазваниеИсключения e1) {
   // Блок catch
  }
```

Код, предрасположенный к исключениям, размещается в блоке `try`. В случае возникновения исключения, обработка данного исключения будет производиться соответствующим блоком `catch`. За каждым блоком `try` должен немедленно следовать блок `catch` либо блок `finally`.

Оператор `catch` включает объявление типа исключения, которое предстоит обработать. При возникновении исключения в защищенном коде, блок `catch` (либо блоки), следующий за `try`, будет проверен. В случае, если тип произошедшего исключения представлен в блоке `catch`, исключение передается в блок `catch` аналогично тому, как аргумент передается в параметр метода.

За блоком `try` могут следовать несколько блоков `catch`. Синтаксис многократных блоков `catch` выглядит следующим образом:

```java
  try {
     // Защищенный код
  }catch(ИсключениеТип1 e1) {
     // Блок catch
  }catch(ИсключениеТип2 e2) {
     // Блок catch
  }catch(ИсключениеТип3 e3) {
     // Блок catch
  }
```

Представленные выше операторы демонстрируют три блока `catch`, однако, после однократного `try` количество данных используемых блоков может быть произвольным. В случае возникновения исключения в защищенном коде, исключение выводится в первый блок `catch` в списке. Если тип данных генерируемого исключения совпадает с `ИсключениеТип1`, он перехватывается в указанной области. В обратном случае, исключение переходит ко второму оператору `catch`. Это продолжается до тех пор, пока не будет произведен перехват исключения, либо оно не пройдет через все операторы, в случае чего выполнение текущего метода будет прекращено, и исключение будет перенесено к предшествующему методу в стеке вызовов.

В Java `finally` следует за блоком `try` либо блоком `catch`. Блок `finally` в коде выполняется всегда независимо от наличия исключения.

Использование блока `finally` позволяет запустить какой-либо оператор, предназначенный для очистки, не зависимо от того, что происходит в защищенном коде.

Блок `finally` в Java появляется по окончании блоков `catch`, его синтаксис выглядит следующим образом:

```java
  try {
     // Защищенный код
  }catch(ИсключениеТип1 e1) {
     // Блок catch
  }catch(ИсключениеТип2 e2) {
     // Блок catch
  }catch(ИсключениеТип3 e3) {
     // Блок catch
  }finally {
     // Блок finally всегда выполняется.
  }
```

Важно:
- Выражение catch не может существовать без оператора try
- При наличии блока try/catch, выражение finally не является обязательным
- Блок try не может существовать при отсутствии выражения catch либо выражения finally
- Существование какого-либо кода в промежутке между блоками try, catch, finally является невозможным

[:top: Содержание](#содержание)

____

## Ключевые слова throw/throws

В случае если метод не может осуществить обработку контролируемого исключения, производится соответствующее уведомление при использовании ключевого слова `throws` в Java. Ключевое слово `throws` появляется в конце сигнатуры метода.

При использовании ключевого слова `throw` вы можете произвести обработку вновь выявленного исключения либо исключения, которое было только что перехвачено.

Следует внимательно различать ключевые слова `throw` и `throws` в Java, так как `throws` используется для отложенной обработки контролируемого исключения, а `throw`, в свою очередь, используется для вызова заданного исключения.

```java
    public void deposit(double amount) throws RemoteException {
      // Реализация метода
      throw new RemoteException();
    }
```

[:top: Содержание](#содержание)

____

## Конструкция try-with-resources

В норме, при использовании различных видов ресурсов, таких как потоки, соединения и др., нам предстоит закрыть их непосредственно при использовании блока `finally`.

Конструкция `try-with-resources`, также именуемая как автоматическое управление ресурсами, представляет новый механизм обработки исключений, который был представлен в 7-ой версии Java, осуществляя автоматическое закрытие всех ресурсов, используемых в рамках блока `try/catch`.

Чтобы воспользоваться данным оператором, вам всего лишь нужно разместить заданные ресурсы в круглых скобках, после чего созданный ресурс будет автоматически закрыт по окончании блока.

```java
  try(FileReader fr = new FileReader("Путь к файлу")) {
     // использование ресурса
     }catch() {
        // тело catch 
     }
  }
```

[:top: Содержание](#содержание)

____

## Создание своих исключений

При записи собственных классов исключений следует принимать во внимание следующие аспекты:
- Все исключения должны быть дочерними элементами Throwable
- Если вы планируете произвести запись контролируемого исключения с автоматическим использованием за счет правила обработки или объявления, вам следует расширить класс Exception
- Если вы хотите произвести запись исключения на этапе выполнения, вам следует расширить класс RuntimeException

```java
   class MyException extends Exception {
   }
```

[:top: Содержание](#содержание)

____

## Разница между error и exception

Ошибка указывает на проблему, которая в основном возникает из-за нехватки системных ресурсов. И наше приложение не должно обнаруживать эти типы проблем. Некоторые из примеров ошибок — сбой системы и ошибка нехватки памяти. Ошибки в основном возникают во время выполнения, так как они относятся к непроверенному типу. 

Исключения — это проблемы, которые могут возникнуть во время выполнения и во время компиляции. Как правило это происходит в коде, написанном разработчиками. То есть exception более предсказуемые и более зависящие от нас как от разработчиков. В это же время errors более случайны и более независимы от нас, а скорее зависимы от неполадок самой системы, в которой работает наше приложение.

[:top: Содержание](#содержание)

____

# Stream API

____

## Введение в Stream API

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.

При работе со Stream API важно понимать, что все операции с потоками бывают либо ***терминальными (terminal)***, либо ***промежуточными (intermediate)***.

Промежуточные операции возвращают трансформированный поток. К возвращенному потоку также можно применить ряд промежуточных операций.

Конечные или терминальные операции возвращают конкретный результат. Например, в примере выше метод `count()` представляет терминальную операцию и возвращает число. После этого никаких промежуточных операций естественно применять нельзя.

Все потоки производят вычисления, в том числе в промежуточных операциях, только тогда, когда к ним применяется терминальная операция.

В основе Stream API лежит интерфейс `BaseStream`. Его полное определение:

```java
  interface BaseStream<T , S extends BaseStream<T , S>>
```

Здесь параметр `T` означает тип данных в потоке, а `S` - тип потока, который наследуется от интерфейса `BaseStream`.

BaseStream определяет базовый функционал для работы с потоками, которые реализуется через его методы:
- `void close()`: закрывает поток
- `boolean isParallel()`: возвращает true, если поток является параллельным
- `Iterator<Т> iterator()`: возвращает ссылку на итератор потока
- `Spliterator<Т> spliterator()`: возвращает ссылку на сплитератор потока
- `S parallel()`: возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)
- `S sequential()`: возвращает последовательный поток
- `S unordered()`: возвращает неупорядоченный поток

От интерфейса `BaseStream` наследуется ряд интерфейсов, предназначенных для создания конкретных потоков:

- `Stream<T>`: используется для потоков данных, представляющих любой ссылочный тип
- `IntStream`: используется для потоков с типом данных int
- `DoubleStream`: используется для потоков с типом данных double
- `LongStream`: используется для потоков с типом данных long

При работе с потоками, которые представляют определенный примитивный тип - `double`, `int`, `long` проще использовать интерфейсы `DoubleStream`, `IntStream`, `LongStream`. Но в большинстве случаев, как правило, работа происходит с более сложными данными, для которых предназначен интерфейс `Stream<T>`. Рассмотрим некоторые его методы:

- `boolean allMatch(Predicate<? super T> predicate)`: возвращает true, если все элементы потока удовлетворяют условию в предикате. Терминальная операция
- `boolean anyMatch(Predicate<? super T> predicate)`: возвращает true, если хоть один элемент потока удовлетворяют условию в предикате. Терминальная операция
- `<R,A> R collect(Collector<? super T,A,R> collector)`: добавляет элементы в неизменяемый контейнер с типом R. T представляет тип данных из вызывающего потока, а A - тип данных в контейнере. Терминальная операция
- `long count()`: возвращает количество элементов в потоке. Терминальная операция.
- `Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)`: объединяет два потока. Промежуточная операция
- `Stream<T> distinct()`: возвращает поток, в котором имеются только уникальные данные с типом T. Промежуточная операция
- `Stream<T> dropWhile(Predicate<? super T> predicate)`: пропускает элементы, которые соответствуют условию в predicate, пока не попадется элемент, который не соответствует условию. Выбранные элементы возвращаются в виде потока. Промежуточная операция.
- `Stream<T> filter(Predicate<? super T> predicate)`: фильтрует элементы в соответствии с условием в предикате. Промежуточная операция
- `Optional<T> findFirst()`: возвращает первый элемент из потока. Терминальная операция
- `Optional<T> findAny()`: возвращает первый попавшийся элемент из потока. Терминальная операция
- `void forEach(Consumer<? super T> action)`: для каждого элемента выполняется действие action. Терминальная операция
- `Stream<T> limit(long maxSize)`: оставляет в потоке только maxSize элементов. Промежуточная операция
- `Optional<T> max(Comparator<? super T> comparator)`: возвращает максимальный элемент из потока. Для сравнения элементов применяется компаратор comparator. Терминальная операция
- `Optional<T> min(Comparator<? super T> comparator)`: возвращает минимальный элемент из потока. Для сравнения элементов применяется компаратор comparator. Терминальная операция
- `<R> Stream<R> map(Function<? super T,? extends R> mapper)`: преобразует элементы типа T в элементы типа R и возвращает поток с элементами R. Промежуточная операция
- `<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`: позволяет преобразовать элемент типа T в несколько элементов типа R и возвращает поток с элементами R. Промежуточная операция
- `boolean noneMatch(Predicate<? super T> predicate)`: возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате. Терминальная операция
- `Stream<T> skip(long n)`: возвращает поток, в котором отсутствуют первые n элементов. Промежуточная операция.
- `Stream<T> sorted()`: возвращает отсортированный поток. Промежуточная операция.
- `Stream<T> sorted(Comparator<? super T> comparator)`: возвращает отсортированный в соответствии с компаратором поток. Промежуточная операция.
- `Stream<T> takeWhile(Predicate<? super T> predicate)`: выбирает из потока элементы, пока они соответствуют условию в predicate. Выбранные элементы возвращаются в виде потока. Промежуточная операция.
- `Object[] toArray()`: возвращает массив из элементов потока. Терминальная операция.

Несмотря на то, что все эти операции позволяют взаимодействовать с потоком как неким набором данных наподобие коллекции, важно понимать отличие коллекций от потоков:

- Потоки не хранят элементы. Элементы, используемые в потоках, могут храниться в коллекции, либо при необходимости могут быть напрямую сгенерированы.
- Операции с потоками не изменяют источника данных. Операции с потоками лишь возвращают новый поток с результатами этих операций.
- Для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток.

[:top: Содержание](#содержание)

____

## Создание потока данных

Для создания потока данных можно применять различные методы. В качестве источника потока мы можем использовать коллекции. В частности, в JDK 8 в интерфейс ***Collection***, который реализуется всеми классами коллекций, были добавлены два метода для работы с потоками:

- `default Stream<E> stream`: возвращается поток данных из коллекции
- `default Stream<E> parallelStream`: возвращается параллельный поток данных из коллекции

Пример: 

```java
  public static void main(String[] args) {
        ArrayList<String> cities = new ArrayList<String>();
        Collections.addAll(cities, "Париж", "Лондон", "Мадрид");
        cities.stream() // получаем поток
            .filter(s->s.length()==6) // применяем фильтрацию по длине строки
            .forEach(s->System.out.println(s)); // выводим отфильтрованные строки на консоль
    }
```

Здесь с помощью вызова `cities.stream()` получаем поток, который использует данные из списка `cities`. С помощью каждой промежуточной операции, которая применяется к потоку, мы также можем получить поток с учетом модификаций. Например, мы можем изменить предыдущий пример следующим образом:

```java
  ArrayList<String> cities = new ArrayList<String>();
  Collections.addAll(cities, "Париж", "Лондон", "Мадрид");

  Stream<String> citiesStream = cities.stream(); // получаем поток
  citiesStream = citiesStream.filter(s->s.length()==6); // применяем фильтрацию по длине строки
  citiesStream.forEach(s->System.out.println(s)); // выводим отфильтрованные строки на консоль
```

Важно, что после использования терминальных операций другие терминальные или промежуточные операции к этому же потоку не могут быть применены, поток уже употреблен. Например, в следующем случае мы получим ошибку:

```java
  citiesStream.forEach(s->System.out.println(s)); // терминальная операция употребляет поток
  long number = citiesStream.count(); // здесь ошибка, так как поток уже употреблен
  System.out.println(number);
  citiesStream = citiesStream.filter(s->s.length()>5); // тоже нельзя, так как поток уже употреблен
```

Фактически жизненный цикл потока проходит следующие три стадии:
1) Создание потока
2) Применение к потоку ряда промежуточных операций
3) Применение к потоку терминальной операции и получение результата

Кроме вышерассмотренных методов мы можем использовать еще ряд способов для создания потока данных. Один из таких способов представляет метод `Arrays.stream(T[] array)`, который создает поток данных из массива:

```java	
  Stream<String> citiesStream = Arrays.stream(new String[]{"Париж", "Лондон", "Мадрид"}) ;
  citiesStream.forEach(s->System.out.println(s)); // выводим все элементы массива
```

Для создания потоков `IntStream`, `DoubleStream`, `LongStream` можно использовать соответствующие перегруженные версии этого метода:

```java
  IntStream intStream = Arrays.stream(new int[]{1,2,4,5,7});
  intStream.forEach(i->System.out.println(i));

  LongStream longStream = Arrays.stream(new long[]{100,250,400,5843787,237});
  longStream.forEach(l->System.out.println(l));

  DoubleStream doubleStream = Arrays.stream(new double[] {3.4, 6.7, 9.5, 8.2345, 121});
  doubleStream.forEach(d->System.out.println(d));
```

И еще один способ создания потока представляет статический метод `of(T..values)` класса `Stream`:

```java
  Stream<String> citiesStream =Stream.of("Париж", "Лондон", "Мадрид");
  citiesStream.forEach(s->System.out.println(s));

  // можно передать массив
  String[] cities = {"Париж", "Лондон", "Мадрид"};
  Stream<String> citiesStream2 =Stream.of(cities);

  IntStream intStream = IntStream.of(1,2,4,5,7);
  intStream.forEach(i->System.out.println(i));

  LongStream longStream = LongStream.of(100,250,400,5843787,237);
  longStream.forEach(l->System.out.println(l));

  DoubleStream doubleStream = DoubleStream.of(3.4, 6.7, 9.5, 8.2345, 121);
  doubleStream.forEach(d->System.out.println(d));
```

[:top: Содержание](#содержание)

____

## Фильтрация, перебор и отображение

### Перебор элементов. Метод forEach

Для перебора элементов потока применяется метод `forEach()`, который представляет терминальную операцию. В качестве параметра он принимает объект `Consumer<? super String>`, который представляет действие, выполняемое для каждого элемента набора. Например:

```java
  Stream<String> citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
  citiesStream.forEach(s->System.out.println(s));
```

Фактически это будет аналогично перебору всех элементов в цикле for и выполнению с ними действия, а именно вывод на консоль.

Можно сократить метод `forEach()`:

```java
  Stream<String> citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
  citiesStream.forEach(System.out::println);
```

### Фильтрация. Метод filter

Для фильтрации элементов в потоке применяется метод `filter()`, который представляет промежуточную операцию. Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>` и возвращает новый поток из элементов, которые удовлетворяют этому условию:

```java
  Stream<String> citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
  citiesStream.filter(s->s.length()==6).forEach(s->System.out.println(s));
```

Здесь условие `s.length()==6` возвращает `true` для тех элементов, длина которых равна `6` символам.

Более сложный пример:

```java
  class Phone{
    private String name;
    private int price;
  }
```

```java
  Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000));
         
  phoneStream.filter(p->p.getPrice()<50000).forEach(p->System.out.println(p.getName()));
```

### Отображение. Метод map

Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой, то есть получить из элемента одного типа элемент другого типа. Для отображения используется метод `map`, который имеет следующее определение:

```java
  <R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

Передаваемая в метод `map` функция задает преобразование от объектов типа `T` к типу `R`. И в результате возвращается новый поток с преобразованными объектами.

Преобразуем тип `Phone` к `String`:

```java
  Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                  new Phone("Samsung Galaxy S 6", 40000));

  phoneStream
      .map(p-> p.getName()) // помещаем в поток только названия телефонов
      .forEach(s->System.out.println(s));
```

Для преобразования объектов в типы `Integer`, `Long`, `Double` определены специальные методы `mapToInt()`, `mapToLong()` и `mapToDouble()` соответственно.

### Плоское отображение. Метод flatMap

Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько. Данную операцию выполняет метод `flatMap`:

```java
  <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)
```

Из одного объекта `Phone` нам надо получить два объекта с информацией, например, в виде строки. Для этого применим `flatMap`:

```java
  Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                  new Phone("Samsung Galaxy S 6", 40000));

  phoneStream
      .flatMap(p->Stream.of(
              String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
              String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
      ))
      .forEach(s->System.out.println(s));
```

[:top: Содержание](#содержание)

____

## Сортировка

Коллекции, на основе которых нередко создаются потоки, уже имеют специальные методы для сортировки содержимого. Однако класс `Stream` также включает возможность сортировки. Такую сортировку мы можем задействовать, когда у нас идет набор промежуточных операций с потоком, которые создают новые наборы данных, и нам надо эти наборы отсортировать.

Для простой сортировки по возрастанию применяется метод `sorted()`:

```java
  public static void main(String[] args) {
          
        List<String> phones = new ArrayList<String>();
        Collections.addAll(phones, "iPhone X", "Nokia 9", "Huawei Nexus 6P",
                "Samsung Galaxy S8", "LG G6", "Xiaomi MI6",
                "ASUS Zenfone 3", "Sony Xperia Z5", "Meizu Pro 6",
                "Pixel 2");
          
        phones.stream()
                .filter(p->p.length()<12)
                .sorted() // сортировка по возрастанию
                .forEach(s->System.out.println(s));
  } 
```

Если по каким-то причинам не подходит данный вараинт или же объекты, которые сортируются не реализуют интерфейс `Comparable`, то можно использовать другую версию `sorted()`, которая в качестве параметра принимает компаратор.

[:top: Содержание](#содержание)

____

## Получение подпотока и объединение потоков

### takeWhile

Метод `takeWhile()` выбирает из потока элементы, пока они соответствуют условию. Если попадается элемент, который не соответствует условию, то метод завершает свою работу. Выбранные элементы возвращаются в виде потока.

```java
    public static void main(String[] args) { 
        Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
        numbers.takeWhile(n -> n < 0)
            .forEach(n -> System.out.println(n));
    }
```

При этом несмотря на то, что в потоке больше отрицательных чисел, но метод завершает работу, как только обнаружит первое число, которое не соответствует условию. В этом и состоит отличие, например, от метода `filter()`.

Чтобы в данном случае охватить все элементы, которые меньше нуля, поток следует предварительно отсортировать:

```java
    Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
    numbers.sorted().takeWhile(n -> n < 0)
            .forEach(n -> System.out.println(n));
```

### dropWhile

Метод `dropWhile()` выполняет обратную задачу - он пропускает элементы потока, которые соответствуют условию до тех пор, пока не встретит элемент, который НЕ соответствует условию:

```java
    Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
    numbers.sorted().dropWhile(n -> n < 0)
        .forEach(n -> System.out.println(n));
```

### concat

Статический метод `concat()` объединяет элементы двух потоков, возвращая объединенный поток:

```java
    public static void main(String[] args) {
        Stream<String> people1 = Stream.of("Tom", "Bob", "Sam");
        Stream<String> people2 = Stream.of("Alice", "Kate", "Sam");
        Stream.concat(people1, people2).forEach(n -> System.out.println(n));
    }
```

### distinct

Метод `distinct()` возвращает только ункальные элементы в виде потока:

```java
    Stream<String> people = Stream.of("Tom", "Bob", "Sam", "Tom", "Alice", "Kate", "Sam");
    people.distinct().forEach(p -> System.out.println(p));
```

[:top: Содержание](#содержание)

____

## Методы skip и limit

Метод `skip(long n)` используется для пропуска `n` элементов. Этот метод возвращает новый поток, в котором пропущены первые `n` элементов.

Метод `limit(long n`) применяется для выборки первых `n` элементов потоков. Этот метод также возвращает модифицированный поток, в котором не более `n` элементов.

Зачастую эта пара методов используется вместе для создания эффекта постраничной навигации.

```java
    Stream<String> phoneStream = Stream.of("iPhone 6 S", "Lumia 950", "Samsung Galaxy S 6", "LG G 4", "Nexus 7");

    phoneStream.skip(1)
        .limit(2)
        .forEach(s->System.out.println(s));
```

В данном случае метод `skip` пропускает один первый элемент, а метод `limit` выбирает два следующих элемента.

Вполне может быть, что метод `skip` может принимать в качестве параметра число большее, чем количество элементов в потоке. В этом случае будут пропущены все элементы, а в результирующем потоке будет 0 элементов.

И если в метод `limit` передается число, большее, чем количество элементов, то просто выбираются все элементы потока.

[:top: Содержание](#содержание)

____

## Операции сведения

Операции сведения представляют терминальные операции, которые возвращают некоторое значение - результат операции.

### count

Метод `count()` возвращает количество элементов в потоке данных:

```java
    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<String>();
        names.addAll(Arrays.asList(new String[]{"Tom", "Sam", "Bob", "Alice"}));
        System.out.println(names.stream().count());  // 4
        // количество элементов с длиной не больше 3 символов
        System.out.println(names.stream().filter(n->n.length()<=3).count());  // 3
    } 
```

### findFirst и findAny

Метод `findFirst()` извлекает из потока первый элемент, а `findAny()` извлекает случайный объект из потока (нередко так же первый):

```java
    ArrayList<String> names = new ArrayList<String>();
    names.addAll(Arrays.asList(new String[]{"Tom", "Sam", "Bob", "Alice"}));

    Optional<String> first = names.stream().findFirst();
    System.out.println(first.get());    // Tom

    Optional<String> any = names.stream().findAny();
    System.out.println(first.get());    // Tom
```

### allMatch, anyMatch, noneMatch

Еще одна группа операций сведения возвращает логическое значение `true` или `false`:
- `boolean allMatch(Predicate<? super T> predicate)`: возвращает true, если все элементы потока удовлетворяют условию в предикате
- `boolean anyMatch(Predicate<? super T> predicate)`: возвращает true, если хоть один элемент потока удовлетворяют условию в предикате
- `boolean noneMatch(Predicate<? super T> predicate)`: возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате

```java
    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<String>();
        names.addAll(Arrays.asList(new String[]{"Tom", "Sam", "Bob", "Alice"}));
         
        // есть ли в потоке строка, длина которой больше 3
        boolean any = names.stream().anyMatch(s->s.length()>3);
        System.out.println(any);    // true
         
        // все ли строки имеют длину в 3 символа
        boolean all = names.stream().allMatch(s->s.length()==3);
        System.out.println(all);    // false
         
        // НЕТ ЛИ в потоке строки "Bill". Если нет, то true, если есть, то false
        boolean none = names.stream().noneMatch(s->s=="Bill");
        System.out.println(none);   // true
    } 
```

### min и max

Методы `min()` и `max()` возвращают соответственно минимальное и максимальное значение. Поскольку данные в потоке могут представлять различные типы, в том числе сложные классы, то в качестве параметра в эти методы передается объект интерфейса `Comparator`, который указывает, как сравнивать объекты:

```java
    Optional<T> min(Comparator<? super T> comparator)
    Optional<T> max(Comparator<? super T> comparator)
```

Оба метода возвращают элемент потока (минимальный или максимальный), обернутый в объект `Optional`.

```java
    public static void main(String[] args) {
         
        ArrayList<Integer> numbers = new ArrayList<Integer>();
        numbers.addAll(Arrays.asList(new Integer[]{1,2,3,4,5,6,7,8,9}));
         
        Optional<Integer> min = numbers.stream().min(Integer::compare);
        Optional<Integer> max = numbers.stream().max(Integer::compare);
        System.out.println(min.get());  // 1
        System.out.println(max.get());  // 9
    } 
```

[:top: Содержание](#содержание)

____

## Метод reduce

Метод `reduce` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции. Он имеет следующие формы:

```java
    Optional<T> reduce(BinaryOperator<T> accumulator)
    T reduce(T identity, BinaryOperator<T> accumulator)
    U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)
```

Первая форма возвращает результат в виде объекта `Optional<T>`.

```java
    public static void main(String[] args) {
        Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
        Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
        System.out.println(result.get()); // 720
    } 
```

Объект `BinaryOperator<T>` представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию, возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату и следующему элементу в наборе бинарную операцию.

Вторая версия метода `reduce()` принимает два параметра

Первый параметр - `T identity` - элемент, который предоставляет начальное значение для функции из второго параметра, а также предоставляет значение по умолчанию, если поток не имеет элементов.

Второй параметр - `BinaryOperator<T> accumulator`, как и первая форма метода `reduce`, представляет ассоциативную функцию, которая запускается для каждого элемента в потоке и принимает два параметра. Первый параметр представляяет промежуточный результат функции, а второй параметр - следующий элемент в потоке. Фактически код этого метода будет равноценен следующей записи:

```java
    T result = identity;
    for (T element : this stream)
        result = accumulator.apply(result, element)
    return result;
```

То есть при первом вызове функция `accumulator` в качестве первого параметра принимает значение `identity`, а в качестве второго параметра - первый элемент потока. При втором вызове первым параметром служит результат первого вызова функции `accumulator`, а вторым параметром - второй элемент в потоке и так далее.

```java
    Stream<Integer> numberStream = Stream.of(-4, 3, -2, 1);
    int identity = 1;
    int result = numberStream.reduce(identity, (x,y)->x * y);
    System.out.println(result);  // 24
```

[:top: Содержание](#содержание)

____

## Тип Optional

Ряд операций сведения, такие как `min`, `max`, `reduce`, возвращают объект `Optional<T>`. Этот объект фактически обертывает результат операции. После выполнения операции с помощью метода `get()` объекта `Optional` мы можем получить его значение

```java
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<Integer>();
        numbers.addAll(Arrays.asList(new Integer[]{1,2,3,4,5,6,7,8,9}));
        Optional<Integer> min = numbers.stream().min(Integer::compare);
        System.out.println(min.get());  // 1
    } 
```

Если поток не содержит вообще никаких данных, то в этом случае программа выдаст исключение `java.util.NoSuchElementException`.

Самой простой способ избежать подобной ситуации - это предварительная проверка наличия значения в `Optional` с помощью метода `isPresent()`. Он возврашает `true`, если значение присутствует в `Optional`, и `false`, если значение отсутствует:

```java
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    Optional<Integer> min = numbers.stream().min(Integer::compare);
    if(min.isPresent()){
        System.out.println(min.get());
    }
```

### orElse

Метод `orElse()` позволяет определить альтернативное значение, которое будет возвращаться, если `Optional` не получит из потока какого-нибудь значения:

```java
    // пустой список
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    Optional<Integer> min = numbers.stream().min(Integer::compare);
    System.out.println(min.orElse(-1)); // -1

    // непустой список
    numbers.addAll(Arrays.asList(new Integer[]{4,5,6,7,8,9}));
    min = numbers.stream().min(Integer::compare);
    System.out.println(min.orElse(-1)); // 4
```

### orElseGet

Метод `orElseGet()` позволяет задать функцию, которая будет возвращать значение по умолчанию:

```java
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<Integer>();
        Optional<Integer> min = numbers.stream().min(Integer::compare);
        Random rnd = new Random();
        System.out.println(min.orElseGet(()->rnd.nextInt(100)));
    } 
```

### orElseThrow

Еще один метод - `orElseThrow` позволяет сгенерировать исключение, если `Optional` не содержит значения:

```java
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    Optional<Integer> min = numbers.stream().min(Integer::compare);
    // генеррация исключения IllegalStateException
    System.out.println(min.orElseThrow(IllegalStateException::new));
```

### Обработка полученного значения

Метод `ifPresent()` определяет действия со значением в `Optional`, если значение имеется:

```java
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.addAll(Arrays.asList(new Integer[]{4,5,6,7,8,9}));
    Optional<Integer> min = numbers.stream().min(Integer::compare);
    min.ifPresent(v->System.out.println(v)); // 4
```

В метод `ifPresent` передается функция, которая принимает один параметр - значение из `Optional`. В данном случае полученное минимальное число выводится на консоль. Но если бы массив `numbers` был бы пустым, и соответственно `Optional` не сдержало бы никакого значения, то никакой ошибки бы не было.

Метод `ifPresentOrElse()` позволяет определить альтернативную логику на случай, если значение в `Optional` отсутствует:

```java
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    Optional<Integer> min = numbers.stream().min(Integer::compare);
    min.ifPresentOrElse(
         v -> System.out.println(v),
        () -> System.out.println("Value not found")
    );
```

В метод `ifPresentOrElse` передается две функции. Первая обрабатывает значение в `Optional`, если оно присутствует. Вторая функция представляет действия, которые выполняются, если значение в `Optional` отсутствует.

[:top: Содержание](#содержание)

____

## Метод collect

Большинство операций класса `Stream`, которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, `ArrayList` или `HashSet`. И для этого у класса `Stream` определен метод `collect`. Первая версия метода принимает в качестве параметра функцию преобразования к коллекции:

```java
    <R,A> R collect(Collector<? super T,A,R> collector)
```

Параметр `R` представляет тип результата метода, параметр `Т` - тип элемента в потоке, а параметр `А` - тип промежуточных накапливаемых данных. В итоге параметр `collector` представляет функцию преобразования потока в коллекцию.

Эта функция представляет объект `Collector`, который определен в пакете `java.util.stream`. Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций, определенных в классе `Collectors`:

- `toList()`: преобразование к типу List
- `toSet()`: преобразование к типу Set
- `toMap()`: преобразование к типу Map

```java
        List<String> phones = new ArrayList<String>();
        Collections.addAll(phones, "iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2", 
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");
          
        List<String> filteredPhones = phones.stream()
                .filter(s->s.length()<10)
                .collect(Collectors.toList());
                 
        for(String s : filteredPhones){
            System.out.println(s);
        }
```

```java
    Set<String> filteredPhones = phones.stream()
                .filter(s->s.length()<10)
                .collect(Collectors.toSet());
```

Вторая форма метода `collect` имеет три параметра:

```java
    <R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)
```

- `supplier`: создает объект коллекции
- `accumulator`: добавляет элемент в коллекцию
- `combiner`: бинарная функция, которая объединяет два объекта

## Группировка

Чтобы сгруппировать данные по какому-нибудь признаку, нам надо использовать в связке метод `collect()` объекта Stream и метод `Collectors.groupingBy()`. Допустим, у нас есть следующий класс:

```java
    class Phone{
        private String name;
        private String company;
        private int price;
    }
```

```java
        Stream<Phone> phoneStream = Stream.of(new Phone("iPhone X", "Apple", 600), 
            new Phone("Pixel 2", "Google", 500),
            new Phone("iPhone 8", "Apple",450),
            new Phone("Galaxy S9", "Samsung", 440),
            new Phone("Galaxy S8", "Samsung", 340));
          
        Map<String, List<Phone>> phonesByCompany = phoneStream.collect(
                Collectors.groupingBy(Phone::getCompany));
          
        for(Map.Entry<String, List<Phone>> item : phonesByCompany.entrySet()){
              
            System.out.println(item.getKey());
            for(Phone phone : item.getValue()){
                  
                System.out.println(phone.getName());
            }
            System.out.println();
        } 
```

Итак, для создания групп в метод `phoneStream.collect()` передается вызов функции `Collectors.groupingBy()`, которая с помощью выражения `Phone::getCompany` группирует объекты по компании. В итоге будет создан объект `Map`, в котором ключами являются названия компаний, а значениями - список связанных с компаниями телефонов.

### Метод Collectors.partitioningBy

Метод `Collectors.partitioningBy()` имеет похожее действие, только он делит элементы на группы по принципу, соответствует ли элемент определенному условию.

```java
    Map<Boolean, List<Phone>> phonesByCompany = phoneStream.collect(
                    Collectors.partitioningBy(p->p.getCompany()=="Apple"));

    for(Map.Entry<Boolean, List<Phone>> item : phonesByCompany.entrySet()){

        System.out.println(item.getKey());
        for(Phone phone : item.getValue()){

            System.out.println(phone.getName());
        }
        System.out.println();
    }
```

В данном случае с помощью условия `p->p.getCompany()=="Apple"` мы смотрим, принадлежит ли телефон компании Apple. Если телефон принадлежит этой компании, то он попадает в одну группу, если нет, то в другую.

### Метод Coollectors.counting

Метод `Collectors.counting` применяется в `Collectors.groupingBy()` для вычисления количества элементов в каждой группе:

```java
    Map<String, Long> phonesByCompany = phoneStream.collect(
            Collectors.groupingBy(Phone::getCompany, Collectors.counting()));

    for(Map.Entry<String, Long> item : phonesByCompany.entrySet()){

        System.out.println(item.getKey() + " - " + item.getValue());
    }
```

### Метод Collectors.summing

Метод `Collectors.summing` применяется для подсчета суммы. В зависимости от типа данных, к которым применяется метод, он имеет следующие формы: `summingInt()`, `summingLong()`, `summingDouble()`. Применим этот метод для подсчета стоимости всех смартфонов по компаниям:

```java
    Map<String, Integer> phonesByCompany = phoneStream.collect(
            Collectors.groupingBy(Phone::getCompany, Collectors.summingInt(Phone::getPrice)));

    for(Map.Entry<String, Integer> item : phonesByCompany.entrySet()){

        System.out.println(item.getKey() + " - " + item.getValue());
    }
```

С помощью выражения `Collectors.summingInt(Phone::getPrice))` мы указываем, что для каждой компании будет вычислять совокупная цена всех ее смартфонов. И поскольку вычисляется результат - сумма для значений типа `int`, то в качестве типа возвращаемой коллекции используется тип` Map<String, Integer>`

### Методы maxBy и minBy

Методы `maxBy` и `minBy` применяются для подсчета минимального и максимального значения в каждой группе. В качестве параметра эти методы принимают функцию компаратора, которая нужна для сравнения значений. Например, найдем для каждой компании телефон с минимальной ценой:

```java
    Map<String, Optional<Phone>> phonesByCompany = phoneStream.collect(
            Collectors.groupingBy(Phone::getCompany, 
                    Collectors.minBy(Comparator.comparing(Phone::getPrice))));

    for(Map.Entry<String, Optional<Phone>> item : phonesByCompany.entrySet()){

        System.out.println(item.getKey() + " - " + item.getValue().get().getName());
    }
```

В качестве возвращаемого значения операции группировки используется объект `Map<String, Optional<Phone>>`. Опять же поскольку группируем по компаниям, то ключом будет выступать строка, а значением - объект `Optional<Phone>`.

### Метод summarizing

Методы `summarizingInt()` / `summarizingLong()` / `summarizingDouble()` позволяют объединить в набор значения соответствующих типов:

```java
    Map<String, IntSummaryStatistics> priceSummary = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany,
            Collectors.summarizingInt(Phone::getPrice)));

    for(Map.Entry<String, IntSummaryStatistics> item : priceSummary.entrySet()){

        System.out.println(item.getKey() + " - " + item.getValue().getAverage());
    }
```

Метод `Collectors.summarizingInt(Phone::getPrice))` создает набор, в который помещаются цены для всех телефонов каждой из групп. Данный набор инкапсулируется в объекте `IntSummaryStatistics`. Соответственно если бы мы применяли методы `summarizingLong()` или `summarizingDouble()`, то соответственно бы получали объекты `LongSummaryStatistics` или `DoubleSummaryStatistics`.

У этих объектов есть ряд методов, который позволяют выполнить различные атомарные операции над набором:

- `getAverage()`: возвращает среднее значение
- `getCount()`: возвращает количество элементов в наборе
- `getMax()`: возвращает максимальное значение
- `getMin()`: возвращает минимальное значение
- `getSum()`: возвращает сумму элементов
- `accept()`: добавляет в набор новый элемент

### Метод mapping

Метод `mapping` позволяет дополнительно обработать данные и задать функцию отображения объектов из потока на какой-нибудь другой тип данных.

```java
    Map<String, List<String>> phonesByCompany = phoneStream.collect(
        Collectors.groupingBy(Phone::getCompany,
            Collectors.mapping(Phone::getName, Collectors.toList())));

    for(Map.Entry<String, List<String>> item : phonesByCompany.entrySet()){

        System.out.println(item.getKey());
        for(String name : item.getValue()){
            System.out.println(name);
        }
    }
```

Выражение `Collectors.mapping(Phone::getName, Collectors.toList())` указывает, что в группу будут выделятся названия смартфонов, причем группа будет представлять объект `List`.

[:top: Содержание](#содержание)

____

## Параллельные потоки

Кроме последовательных потоков ***Stream API*** поддерживает параллельные потоки. Распараллеливание потоков позволяет задействовать несколько ядер процессора (если целевая машина многоядерная) и тем самым может повысить производительность и ускорить вычисления. В то же время говорить, что применение параллельных потоков на многоядерных машинах однозначно повысит производительность - не совсем корректно. В каждом конкретном случае надо проверять и тестировать.

Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта `Stream` метод `parallel`. Кроме того, можно также использовать метод `parallelStream()` интерфейса `Collection` для создания параллельного потока из коллекции.

В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.

```java
        List<String> people = Arrays.asList("Tom","Bob", "Sam", "Kate", "Tim");
 
        System.out.println("Последовательный поток");
        people.stream().filter(p->p.length()==3).forEach(System.out::println);
 
        System.out.println("\nПараллельный поток");
        people.parallelStream().filter(p->p.length()==3).forEach(System.out::println);
```

В данном случае сначала для списка `people` создаем поток и выполняем над ним ряд операций в последовательном режиме. В частности, находим в списке строки, длина которых равна `3` и выводим их на консоль. В этом случае все операции с потоком будут производиться над элементами списка в том порядке, в котоом элементы идут в списке.

Затем с помощью метода `people.parallelStream()` для списка создается параллельный поток. Причем применяются те же операции, однако теперь порядок, в котором над элементами списка будут производиться операции, не детерминирован.

В случае с параллельным потоком вывод недетерминирован и может отличаться.

Однако не все функции можно без ущерба для точности вычисления перенести с последовательных потоков на параллельные. Прежде всего такие функции должны быть без сохранения состояния и ассоциативными, то есть при выполнении слева направо давать тот же результат, что и при выполнении справа налево, как в случае с произведением чисел.

### Вопросы производительности в параллельных операциях

Фактически применение параллельных потоков сводится к тому, что данные в потоке будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются финальные операции. Рассмотрим некоторые критерии, которые могут повлиять на производительность в параллельных потоках:

- Размер данных. Чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
- Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
- Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из `ArrayList` легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа `LinkedList` - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
- Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов

### Упорядоченность в параллельных потоках

Как правило, элементы передаются в поток в том же порядке, в котором они определены в источнике данных. При работе с параллельными потоками система сохраняет порядок следования элементов. Исключение составляет метод `forEach()`, который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод `forEachOrdered`:

```java
phones.parallelStream()
    .sorted()
    .forEachOrdered(s->System.out.println(s));
```

Сохранение порядка в параллельных потоках увеличивает издержки при выполнении. Но если нам порядок не важен, то мы можем отключить его сохранение и тем самым увеличить производительность, использовав метод `unordered`:

```java
phones.parallelStream()
    .sorted()
    .unordered()
    .forEach(s->System.out.println(s));
```

[:top: Содержание](#содержание)

____

# Spring Framework



[:top: Содержание](#содержание)

____
