# Теория для подготовки к собеседованию Java-разработчик (junior)

## Содержание

- [Java Core](#java-core)
  - [ООП. Наследование](#ооп-наследование)
  - [ООП. Инкапусляция](#ооп-инкапсуляция)
  - [ООП. Полиморфизм](#ооп-полиморфизм)
  - [ООП. Абстракция](#ооп-абстракция)
  - [Модификаторы доступа](#модификаторы-доступа)
  - [Конструктор](#конструктор)
  - [Связь любых классов с Object](#связь-любых-классов-с-object)
  - [Local Variable](#local-variable)
  - [Instance Variable](#instance-variable)
  - [Объект](#объект)
  - [Класс](#класс)
  - [Интерфейс](#интерфейс)
  - [Абстрактный класс](#абстрактный-класс)
  - [Абстрактный метод](#абстрактный-метод)
  - [Разница между интерфейсом и абстрактным классом](#разница-между-интерфейсом-и-абстрактным-классом)
  - [Типы данных](#типы-данных)
  - [Автоупаковка и автораспаковка](#автоупаковка-и-автораспаковка)
  - [Mutable и Immutable](#mutable-и-immutable)
  - [Final](#final)
  - [Static](#static)
  - [Сигнатура метода](#сигнатура-метода)
  - [Отношения между классами (объектами)](#отношения-между-классами-объектами)
  - [Ассоциация. Агрегация и композиция](#ассоциация-агрегация-и-композиция)
  - [Разница между == и equals()](#разница-между--и-equals)
  - [equals()](#equals)
  - [hashCode()](#hashcode)
  - [Контракт между equals() и hashCode()](#контракт-между-equals-и-hashcode)
  - [Правила переопределения equals()](#правила-переопределения-equals)
  - [Коллизия в hashCode](#коллизия-в-hashcode)
  - [Класс String](#класс-string)
  - [StringBuilder и StringBuffer](#stringbuilder-и-stringbuffer)
  - [String Pool (строковый пул)](#string-pool-строковый-пул)
  - [Память в Java](#память-в-java)

# Java Core

____

## ООП. Наследование

С помощью наследования можно создавать дочерние классы ***(child)*** на основе родительских ***(parent)***, путем наследования свойств и поведения. В Java для наследования используется ключевое слово ***extends***

**Особенности наследования:**
-	Множественное наследование в Java отсутствует
-	Приватные поля и методы тоже наследуются, только к ним нет доступа у наследника (решение: геттеры и сеттеры)
-	final классы не наследуются
-	final методы не переопределяются
-	static методы и переменные не наследуются (так как привязаны к классам, а не объектам)
-	При наследовании от абстрактных классов, обязательна реализация их абстрактных методов, либо текущий класс тоже нужно объявить абстрактным
-	При наличии не дефолтных конструкторов в родителе, в классе потомке их необходимо переопределять
-	Переопределенным методам в наследнике можно расширять модификаторы доступа: private -> default -> protected -> public
-	Переопределенным методам можно сужать присваиваемые исключения: Exception -> IOException -> FileNotFoundException

[:top: Содержание](#содержание)

____

## ООП. Инкапсуляция

Сокрытие отдельных деталей внутреннего устройства классов от внешних по отношению к нему объектов или пользователей. За инкапсуляцию отвечают ***модификаторы доступа***

[:top: Содержание](#содержание)

____

## ООП. Полиморфизм

Возможность идентично использовать объекты с одинаковыми интерфейсами без информации о конкретном типе этого объекта. Один интерфейс – множество реализаций. В Java за полиморфизм отвечают ключевые слова ***extends*** и ***implements***
Существует два вида полиморфизма – раннее и позднее связывание

**Статический полиморфизм (раннее связывание):**
- Происходит во время компиляции
- Решает, какой метод выполнять во время компиляции
- Перегрузка методов – пример статического полиморфизма
- К нему относятся приватные, статические и терминальные методы
- Наследование не участвует в раннем связывании
- В статическом полиморфизме участвуют не конкретные объекты, а информация о классе, тип которого представлен 

**Динамический полиморфизм (позднее связывание):**
- Происходит во время выполнения
- Решает, какая конкретно реализация будет у метода во время выполнения 
- Переопределение метода – пример динамического полиморфизма
- Позднее связывание – это назначение конкретного объекта, ссылки его типа или его суперкласса
- Наследование связано с динамическим полиморфизмом

[:top: Содержание](#содержание)

____

## ООП. Абстракция

Придание объекту характеристик, которые отличают его от всех других объектов, четко определяя его концептуальные границы.  В Java за абстракцию отвечают ***интерфейсы***

[:top: Содержание](#содержание)

____

## Модификаторы доступа

Инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.
- private – только класс, внутри которого он объявлен
- default (не указан) – доступ только в конкретном пакете, в котором объявлен класс, метод, переменная
- protected – такой же доступ как в default, но еще и для тех классов, которые наследуются от класса с модификатором protected
- public – полный доступ во всем приложении

[:top: Содержание](#содержание)

____

## Конструктор

- Когда новый объект создается, программа использует для этого соответствующий конструктор
- Конструктор похож на метод. Его особенность заключается в том, что нет возвращаемого элемента, а его имя совпадает с именем класса
- Если не создается явно ни одного конструктора, то пустой конструктор будет создан автоматически
- Конструктор может быть переопределен
- Если был создан конструктор с параметрами, а нужен еще и пустой, то его нужно писать отдельно, так как он не создается автоматически при уже существующем с параметрами

[:top: Содержание](#содержание)

____

## Связь любых классов с Object

Все классы прямо или через предков наследуются от класса Object

[:top: Содержание](#содержание)

____

## Local variable

Переменная, которая определена внутри метода и существует до тех пор, пока выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать

[:top: Содержание](#содержание)

____

## Instance Variable

Переменная, которая определена внутри класса, и она существует до того момента, пока существует объект

[:top: Содержание](#содержание)

## Объект

Объекты – некоторые сгруппированные, в которых содержатся различные методы, для работы с этими данными

[:top: Содержание](#содержание)

____

## Класс

Класс – шаблон для создания объектов. Может быть множество объектов одного класса

[:top: Содержание](#содержание)

____

## Интерфейс

Совокупность методов и правил взаимодействия элементов системы. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой
- Все методы в интерфейсы публичные и абстрактные 
- Все переменные public static final
- Бесконечное кол-во имплементаций
- Классы, которые реализуют интерфейс должны предоставить реализацию всех методов, которые есть в интерфейсе

[:top: Содержание](#содержание)

____

## Абстрактный класс

Класс, который не может иметь экземпляров. Так же он может содержать абстрактные методы

[:top: Содержание](#содержание)

____

## Абстрактный метод

Метод, который создан без реализации с ключевым словом abstract в абстрактном классе

[:top: Содержание](#содержание)

____

## Разница между интерфейсом и абстрактным классом

**Абстрактный класс:**
- Имеет дефолтный конструктор; вызывается при создании потомка
- Содержит как абстрактные методы, так и не абстрактные
- Класс, который наследуется от абстрактного, должен реализовывать только абстрактные методы
- Абстрактный класс может содержать Instance Variable

**Интерфейс:**
- Не имеет никакого конструктора и не может быть инициализирован
- Содержит только абстрактные методы
- Класс, реализующий интерфейс, должен реализовать все методы
- Интерфейсы могут содержать только константы

[:top: Содержание](#содержание)

____

## Типы данных 

В Java типы данных бывают двух видов: примитивные и ссылочные

**Примитивные:**
1)	Целые числа (byte, short, int, long)
2)	Числа с плавающей точкой (float, double)
3)	Логический (Boolean)
4)	Символьный (char)

**Ссылочные:**
1)	Классы
2)	Интерфейсы
3)	Массивы
4)	String

| Примитивные | Ссылочные |
| ----------- | --------- |
| Хранят значение | Хранят ссылку объекта в памяти, на который ссылаются |
| Создаются присваиванием значения | Создаются через конструктор класса (присваивание только создает вторую ссылку) |
| Имеют строго заданный диапазон допустимых значений | По умолчанию – null |
| В аргументы методов попадают копии значения переменной |В методы передается значение ссылки – операция выполняется над оригинальным объектом, на который ссылается переменная|
|  | Могут использоваться для ссылки на любой объект объявленного или совместимого типа |

[:top: Содержание](#содержание)

____

## Автоупаковка и автораспаковка

***Автоупаковка*** – процесс автоматического преобразования из примитивного типа в соответствующий класс обертку

***Автораспаковка*** – преобразование класса обертки в примитив. При null -> исключение NPE (NullPointerException)

[:top: Содержание](#содержание)

____

## Mutable и Immutable

***Mutable*** – объекты, состояние и переменные которых можно изменить после создания

***Immutable*** – объекты, состояние которых нельзя изменить после создания

[:top: Содержание](#содержание)

____

## Final

***final*** можно использовать для переменных, методов и классов
- final переменную нельзя переназначить на другой объект
- final метод не может быть переопределен
- final класс не может иметь наследников

[:top: Содержание](#содержание)

____

## Static

***static*** – модификатор, применяемый к полю, блоку, методу или внутреннему классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу

- НЕЛЬЗЯ получить доступ к НЕ статическим членам класса, внутри статического контекста (метода/блока/…)
- В отличии от локальных переменных, статические поля и методы НЕ потокобезопасны. Учитывая, что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите. При использовании статических переменных они должны бить синхронизированы (synchronized) 
- Применяя статические методы, отсутствует необходимость каждый раз создавать новый объект. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны
- Нельзя переопределить статические методы. При попытке переопределения лишь спрячем метод суперкласса, такое явление называется сокрытием
- Объявить статическим можно и класс, за исключением класса верхнего уровня. Такие классы известны как “вложенные статические классы” (nested static class). Они бывают полезными для представления улучшенных связей
- Модификатор static так же можно объявить в статическом блоке инициализации, который будет выполнен во время загрузки класса
- Статические методы связываются во время компиляции, в отличии от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно статические методы не могут быть переопределены, так как полиморфизм во время выполнения не распространяется на них
- Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса
- Во время сериализации статические поля, переменные не сериализуются
- static import. Данный модификатор имеет много общего со стандартным import, но в отличии от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, можно получить доступ без указания имени класса

[:top: Содержание](#содержание)

____

## Сигнатура метода

Сигнатура метода – это имя метода плюс его аргументы (причем порядок аргументов имеет значение). В сигнатуру метода не входит возвращаемое значение, а также бросаемы исключения.

Пример правильной сигнатуры:

```java
  doSomething(int a, double b, double c)
```

Пример неправильной сигнатуры: 

```java
  int doSomething(int firstArg, int secondArg) throws Exception
```

Сигнатура метода в сочетании с возвращаемым типом и бросаемыми исключениями называется **контрактом метода**

[:top: Содержание](#содержание)

____

## Отношения между классами (объектами) 

В Java есть два вида отношений

***IS-A:***

Принцип IS-A в ООП основан на наследовании классов или реализации интерфейсов. К примеру, если класс **Lion** наследует класс **Cat**, мы говорим, что **Lion** является **Cat**

    Lion IS-A Cat
    
(но не всякий **Cat** является **Lion**)

***HAS-A:***

***Ассоциация*** – это один класс ссылается на другой (или на друг друга)

Например, класс **Car** может ссылаться на класс **Passenger**:

    Car HAS-A Passenger
    
И наоборот: если **Passenger** имеет ссылку на **Car**:

    Passenger HAS-A Car

[:top: Содержание](#содержание)

____

## Ассоциация. Агрегация и композиция

Агрегация и композиция – частные случаи ассоциации

***Агрегация*** – отношение, когда один объект является частью другого (но не обязательно это связь должна быть). Например: пассажир может находиться в машине, так же их может быть несколько или не быть совсем. Один пассажир, несколько или ни одного – от этого не зависит работоспособность второго в агрегации класса. Агрегация более свободные ассоциативные отношения классов.

***Композиция*** – более жесткое отношение, когда объект является не просто частью другого, но и работа второго зависит от первого. Например, двигатель может быть без машины, но вне машины он бесполезен, так же и машина не может работать без двигателя.

[:top: Содержание](#содержание)

____

## Разница между == и equals()

При сравнении примитивных типов используется ==, так как переменные содержат конкретные значения и есть возможность их сравнить. Так же примитивные переменные не являются объектами – они не наследуются от класса Object и не имеют метода equals().
Когда сравниваем ссылочные переменные, то == будет сравнивать лишь значение ссылок, на тот же объект ведет ссылка или нет. И даже при условии, что объекты идентичны, то результат такого сравнения будет **false**, так как это другой объект.
Для сравнения ссылочных переменных надо использовать метод equals().
Важно заметить, что для корректной работы метода equals() его необходимо переопределить, в противном случае он будет работать так же, как и ==

[:top: Содержание](#содержание)

____

## equals()

***equals()*** – метод класса Object, задача которого сравнивать объекты и определять равны они или нет

[:top: Содержание](#содержание)

____

## hashCode()

***hashCode()*** – метод класса Object, который генерирует некоторое число на основе предоставленного объекта

[:top: Содержание](#содержание)

____

## Контракт между equals() и hashCode()

Для корректной работы методов equals() и hashCode() в первую очередь их нужно переопределить.
После чего они должны соблюдать правила:
- Одинаковые объекты, для которых сравнение через equals() возвращает **true**, обязательно имеют одинаковые хэш-коды
- Объекты с одинаковыми хэш-кодами не всегда могут быть равны

[:top: Содержание](#содержание)

____

## Правила переопределения equals()

***Рефлексивность*** – для любого значения **x** выражение вида ```x.equals(x)``` всегда должно возвращать **true** (если ```x != null```)

***Симметричность*** – для любых значений **x** и **y** выражение вида ```x.equals(y)``` должно возвращать **true** только в том случае, если ```y.equals(x)``` тоже возвращает **true**

***Транзитивность*** – для любых значений **x**, **y** и **z**, если выражение ```x.equals(y)``` возвращает **true**, при этом ```y.equals(z)``` тоже возвращает **true**, тогда и ```x.equals(z)``` должно возвращать **true**

***Согласованность*** – для любых значение **x** и **y** повторный вызов ```x.equals(y)``` будет всегда возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения двух объектов, не были изменены между вызовами

***Сравнение null*** – для любого значения **x** вызов ```x.equals(null)``` всегда будет возвращать **false**

[:top: Содержание](#содержание)

____

## Коллизия в hashCode

***Коллизия*** – это ситуация, когда два разных объекта имеют одинаковые хэш-коды
Для борьбы с коллизией нужно иметь хорошую имплементацию метода hashCode, чтобы разброс значений был максимальным и шанс повторения значений был минимальным

[:top: Содержание](#содержание)

____

## Класс String

***String*** – стандартный класс в Java, отвечающий за хранение и манипуляции со строковыми значениями, является immutable классом. Так же String является final. 
Особенности:
- Благодаря неизменности, хэш-код экземпляра класса кэшируется. Его не нужно вычислять каждый раз
- Класс String можно использовать в многопоточной среде без дополнительной синхронизации
- Для него перегружен оператор ```+``` для конкатенации строк, поэтому она выполняется быстро. Под капотом конкатенация строк выполняется StringBuilder’ом или StringBuffer’ом (на усмотрение компилятора) и методом append

[:top: Содержание](#содержание)

____

## StringBuilder и StringBuffer

Это два фактически одинаковых класса с той лишь разницей, что один из них используется в многопоточной среде (StringBuffer)

[:top: Содержание](#содержание)

____

## String Pool (строковый пул)

В памяти Java (Heap) есть область - строковый пул, которая предназначена для хранения строковых значений. 
Например, при создании строки:

```java
  String str = “Hello, World!”;
```

Происходит проверка, имеется ли такое значение в строковом пуле, если нет, то создается новое значение, если имеется, то присваивается ссылка на существующее.
При необходимости можно создать новое значение в пуле даже если такое уже существует, через оператор ```new```

[:top: Содержание](#содержание)

____

## Память в Java

Для оптимальной работы приложения JVM делит память на две области: ***стек (stack)*** и ***куча (heap)***. Каждый раз при создании переменной, обновления переменной, создании метода JVM выделяет область памяти под это в стеке или куче.

***Стек:***

Стек работает по схеме LIFO - last in first out (последний вошел, первый вышел)
При каждом вызове метода, который содержит примитивные значения или ссылки на объекты в куче, то на вершине стека выделяется блок памяти под них
Стек хранит примитивные значения, создаваемых в методах, а также ссылки на объекты в куче, на которые ссылается метод

![стек](https://static.tildacdn.com/tild3461-6261-4863-a635-653039613337/PROgrammer-Stack_1.gif)

Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится свободным для следующего метода.
Особенности стека:
- Стек заполняется и очищается по мере вызова и завершения методов
- Переменные в стеке существуют до тех пор, пока выполняется метод, в котором они были созданы
- Если память стека будет заполнена, то выбросится исключение StackOverFlowError
- Доступ к стеку осуществляется быстрее, чем к куче
- Является потокобезопасным, так как для каждого потока создается свой стек

***Куча:***

Эта область памяти используется для динамического выделения памяти для объектов и классов JRE во время выполнения. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.
Эта область памяти разбита на несколько частей, которые называются поколения:
1) ***Young Generation*** – область, где размещаются новые созданные объекты. Когда она заполняется происходит сборка мусора.
2) ***Old (Tenured) Generation*** – здесь хранятся долгоживущие объекты. Когда объекты из ***Young Generation*** достигают определенного “возраста”, они перемещаются в ***Old Generation***.
3) ***Permanent Generation*** – эта область содержит метаинформацию о классах и методах приложения, но начиная с java 8 данная область памяти была упразднена. 

![куча](https://thumb.tildacdn.com/tild6565-3134-4634-b335-353038373763/-/format/webp/image.png)

Особенности кучи:
- Когда эта область памяти заполняется, то выбрасывается исключение OutOfMemoryError
- Доступ к ней медленнее, чем к стеку
- Эта памяти, в отличии от стека автоматически не освобождается. Для сбора неиспользуемых объектов здесь используется сборщик мусора
- В отличии от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код

[:top: Содержание](#содержание)

____
